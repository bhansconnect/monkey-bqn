âŸ¨
  Lex
âŸ©â‡

# This is a full monkey lang tokenizer based on chapter 1 of the book (so no string or comments).
Lexâ†{
    srcâ†ğ•©
    # Get all the letters, their first index, and the length of chains
    azâ†('_'âŠ¸=âˆ¨('a'âŠ¸â‰¤âˆ§â‰¤âŸœ'z')âˆ¨('A'âŠ¸â‰¤âˆ§â‰¤âŸœ'Z')) src
    fazâ†Â»âŠ¸<âŠ¢az
    lazâ†-ËœËË˜âˆ˜â€¿2â¥Š/0(âˆ¾â‰ âˆ¾Ëœ)az

    # Do the same thing to get all of the numbers
    numâ†('0'âŠ¸â‰¤âˆ§â‰¤âŸœ'9') src
    fnumâ†Â»âŠ¸<num
    lnumâ†-ËœËË˜âˆ˜â€¿2â¥Š/0(âˆ¾â‰ âˆ¾Ëœ)num

    # Only match the first `!=` or `==` in a chain.
    # Repeats will be invalid syntax anyway.
    # So it is fine to parse `====` as `==` `=` `=`.
    nâ€¿eâ†â‹ˆË"!="=âŒœsrc
    onâ€¿oeâ†nâ€¿e
    fneâ†e(âŠ¢âˆ§Â«âˆ˜âˆ§âŸœÂ»)n
    n âˆ§â†© Â¬fne
    e âˆ§â†© Â¬Â»fne
    feeâ†(Â«âˆ§âŠ¢>Â»)e
    e âˆ§â†© (Â¬Â»âˆ¨âŠ¢)fee

    # All other symbols are just single characters.
    tcâ†"+-/*<>;,(){}"
    fcâ†nâˆ¨eâˆ¨tcâˆŠËœsrc

    # Get all illegal tokens
    fxâ†Â¬azâˆ¨numâˆ¨fcâˆ¨onâˆ¨oeâˆ¨srcâˆŠ@+9â€¿10â€¿13â€¿32

    # Final format
    # First array is i: ident, k: keyword, 0: number, e: equals, n: not equals, x: illegal, other tokens: themselves
    # Second array is the index in the original src (This will be used to extract identifiers later).
    # It also could be used for nice error messages.
    # The last array is miscellaneous data.
    # For keywords, it is the keyword type: 1: fn, 2: let, 3: true, 4: false, 5: if, 6: else, 7: return
    # For identifiers and numbers, it is the length of the indentifier.

    # Construct token type array.
    # fc does not update tt becuase characters stay as their orignal value.
    fmâ†fazâˆ¨fnumâˆ¨fneâˆ¨feeâˆ¨fcâˆ¨fx
    ttâ†"i0nex "âŠËœfm/+Â´âˆ§`Â¬fazâ€¿fnumâ€¿fneâ€¿feeâ€¿fx
    tt (fc/src)âŒ¾((/' '=tt)âŠ¸âŠ)â†©

    # Construct index array.
    fâ†/fm

    # Construct data array.
    ffazâ†fm/faz
    ffnumâ†fm/fnum
    dâ†0Â¨tt
    d lazâŒ¾((/ffaz)âŠ¸âŠ)â†©
    d lnumâŒ¾((/ffnum)âŠ¸âŠ)â†©

    # We skipped keywords above. Add them now.
    # Convert identifiers to keywords if they match.
    # This really feels like it could be done better.
    # ~50% of execution time is spent calculating `w` and `kwt`.
    # Originally, I calculated kwt when first extracting identifiers.
    # That also had promise, but was a bit slower than this is.
    iâ†'i'=tt
    wâ†(i/d)â†‘Â¨(i/f)â†“âŒœ<src

    kwsâ†"fn"â€¿"let"â€¿"true"â€¿"false"â€¿"if"â€¿"else"â€¿"return"
    # # fkwâ†kws/âˆ˜â·âŒœ<src
    # tmpâ†((/faz)+âŒœâ†•7)âŠsrcâˆ¾" "
    kwtâ†kwsâŠw
    mkâ†(â‰ âˆ˜kwsâ‰ âŠ¢)kwt
    tt ('k'-'i')âŠ¸+âŒ¾((mk//i)âŠ¸âŠ)â†©
    d (mk/kwt)âŒ¾((mk//i)âŠ¸âŠ)â†©

    ttâ€¿fâ€¿d
}
