srcâ†"let five = 5;
let ten = 10;

let add = fn(x, y) {
  x + y;
};

let result = add(five, ten);
!-/*5;
5 < 10 > 5;

if (5 < 10) {
    return true;
} else {
    return false;
}

10 == 10;
10 != 9;
let nottrue = false;
"

# Get all the letters, their first index, and the length of chains
azâ†('_'âŠ¸=âˆ¨('a'âŠ¸â‰¤âˆ§â‰¤âŸœ'z')âˆ¨('A'âŠ¸â‰¤âˆ§â‰¤âŸœ'Z')) src
fazâ†(Â»<âŠ¢)az
lazâ†fazÃ—(+Ã—0âŠ¸â‰ )`âŒ¾âŒ½ az

# Do the same thing to get all of the numbers
numâ†('0'âŠ¸â‰¤âˆ§â‰¤âŸœ'9') src
fnumâ†(Â»<âŠ¢)num
lnumâ†fnumÃ—(+Ã—0âŠ¸â‰ )`âŒ¾âŒ½ num

# Match all of the keywords
kwsâ†"fn"â€¿"let"â€¿"true"â€¿"false"â€¿"if"â€¿"else"â€¿"return"
piâ†{/laz=â‰ ğ•©}Â¨kws
kwiâ†pi/ËœÂ¨ kws {kwâ†ğ•¨â‹„{kwâ‰¡(â‰ kw)â†‘ğ•©â†“src}Â¨ğ•©}Â¨ pi

â€¢Show >kwsâ€¿kwi

# Only match the first `!=` or `==` in a chain.
# Repeats will be invalid syntax anyway.
# So it is fine to parse `====` as `==` `=` `=`.
nâ€¿eâ†â‹ˆË"!="=âŒœsrc
neâ†e(âŠ¢âˆ§Â«âˆ˜âˆ§âŸœÂ»)n
n (Â¬ne)âŠ¸âˆ§â†©
e (Â¬Â»ne)âŠ¸âˆ§â†©
eeâ†(Â«âˆ§âŠ¢>Â»)e
e ((Â¬Â»âˆ¨âŠ¢)ee)âŠ¸âˆ§â†©

# All other symbols are just single characters.
tcâ†"+-/*<>;,"
fcâ†nâˆ§eâˆ§tcâˆŠËœsrc

â€¢Show â‰>srcâ€¿fazâ€¿lazâ€¿fnumâ€¿lnumâ€¿neâ€¿eeâ€¿fc

# This should now be a full monkey lang tokenizer (minus extensions).
# Of course would have to get more fancy to deal with strings and comments.

# Probably should also double check for no invalid characters instead of skipping them.