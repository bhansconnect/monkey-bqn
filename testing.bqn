srcâ†"let five = 5;
let ten = 10;

let add = fn(x, y) {
  x + y;
};

let result = add(five, ten);
!-/*5;
5 < 10 > 5;

if (5 < 10) {
    return true;
} else {
    return false;
}

10 == 10;
10 != 9;
let nottrue = false;
"

# Get all the letters, their first index, and the length of chains
azâ†('_'âŠ¸=âˆ¨('a'âŠ¸â‰¤âˆ§â‰¤âŸœ'z')âˆ¨('A'âŠ¸â‰¤âˆ§â‰¤âŸœ'Z')) src
fazâ†(Â»<âŠ¢)az
lazâ†fazÃ—(+Ã—0âŠ¸â‰ )`âŒ¾âŒ½ az

# Do the same thing to get all of the numbers
numâ†('0'âŠ¸â‰¤âˆ§â‰¤âŸœ'9') src
fnumâ†(Â»<âŠ¢)num
lnumâ†fnumÃ—(+Ã—0âŠ¸â‰ )`âŒ¾âŒ½ num

# Match all of the keywords
kwsâ†"fn"â€¿"let"â€¿"true"â€¿"false"â€¿"if"â€¿"else"â€¿"return"
piâ†{/laz=â‰ ğ•©}Â¨kws
kwiâ†pi/ËœÂ¨ kws {kwâ†ğ•¨â‹„{kwâ‰¡(â‰ kw)â†‘ğ•©â†“src}Â¨ğ•©}Â¨ pi

# â€¢Show >kwsâ€¿kwi

# Extract keyword types into full array.
kwmâ†-1+â†•â‰ kwi
â€¢Show >kwsâ€¿kwm

câ†â†•â‰ src
kwtâ†+Â´kwm(âŠ£Ã—câŠ¸âˆŠ)Â¨kwi

# Merge keyword tokens back into lengths as negative values
# These 2 steps may go away and instead fall into final merging phase.
lazâ†©kwt+lazÃ—kwt=0

# merge numbers and idents since they ared distinguishable by the first character.
faz fnumâŠ¸+â†©
laz lnumâŠ¸+â†©

# Only match the first `!=` or `==` in a chain.
# Repeats will be invalid syntax anyway.
# So it is fine to parse `====` as `==` `=` `=`.
nâ€¿eâ†â‹ˆË"!="=âŒœsrc
neâ†e(âŠ¢âˆ§Â«âˆ˜âˆ§âŸœÂ»)n
n (Â¬ne)âŠ¸âˆ§â†©
e (Â¬Â»ne)âŠ¸âˆ§â†©
eeâ†(Â«âˆ§âŠ¢>Â»)e
e ((Â¬Â»âˆ¨âŠ¢)ee)âŠ¸âˆ§â†©

# All other symbols are just single characters.
tcâ†"+-/*<>;,"
fcâ†nâˆ¨eâˆ¨tcâˆŠËœsrc

â€¢Show â‰>srcâ€¿fazâ€¿lazâ€¿neâ€¿eeâ€¿fc

# TODO: merged into single compressed structure.
# Will have first that merges all types above.
# Will have token type where:
# i: ident, k: keyword, 0: number, e: equals, n: not equals, other tokens: themselves
# Last array will be length of ident or keyword type (could also encode each keyword separately in token type).

# This should now be a full monkey lang tokenizer (minus extensions).
# Of course would have to get more fancy to deal with strings and comments.

# Probably should also double check for no invalid characters instead of skipping them.